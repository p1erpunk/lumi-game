
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Lumi nel Regno delle Ombre</title>
  <style>
    body {
      margin: 0;
      background: #111;
      color: white;
      font-family: monospace;
      text-align: center;
    }
    canvas {
      background: #000;
      display: block;
      margin: 20px auto;
      border: 2px solid #fff;
    }
    #hud {
      font-size: 18px;
    }
    #fade {
      position: absolute;
      top: 0;
      left: 0;
      background: black;
      width: 100%;
      height: 100%;
      opacity: 0;
      pointer-events: none;
      transition: opacity 1s ease-in-out;
    }
  </style>
</head>
<body>
  <h1>Lumi nel Regno delle Ombre</h1>
  <p id="hud">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è ‚Äî üïì Tempo: 0 ‚Äî ‚≠ê Punti: 0</p>
  <canvas id="gameCanvas" width="800" height="500"></canvas>
  <div id="fade"></div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const hud = document.getElementById('hud');
    const fade = document.getElementById('fade');

    const spriteLumi = new Image();
    const spriteEnemy = new Image();
    const spritePower = new Image();
    const spritePortal = new Image();

    spriteLumi.src = 'assets/lumi.png';
    spriteEnemy.src = 'assets/slime.png';
    spritePower.src = 'assets/power.png';
    spritePortal.src = 'assets/portal.png';

    let loadedImages = 0;
    const totalImages = 4;

    function checkAllLoaded() {
      loadedImages++;
      if (loadedImages === totalImages) {
        loadLevel(currentLevel);
        update();
      }
    }

    spriteLumi.onload = checkAllLoaded;
    spriteEnemy.onload = checkAllLoaded;
    spritePower.onload = checkAllLoaded;
    spritePortal.onload = checkAllLoaded;

    let currentLevel = 0;
    let time = 0;
    let gameOver = false;
    let levelComplete = false;

    const levels = [
      {
        platforms: [
          {x: 0, y: 470, width: 800, height: 30},
          {x: 150, y: 400, width: 100, height: 10},
          {x: 300, y: 350, width: 120, height: 10},
          {x: 500, y: 300, width: 150, height: 10}
        ],
        enemies: [
          {x: 200, y: 370, width: 30, height: 30, dir: 1},
          {x: 550, y: 270, width: 30, height: 30, dir: -1}
        ],
        powerUps: [
          {x: 320, y: 320, width: 20, height: 20, active: true}
        ],
        exitPortal: {x: 750, y: 440, width: 30, height: 30}
      }
    ];

    let player = {
      x: 100,
      y: 100,
      width: 30,
      height: 30,
      vx: 0,
      vy: 0,
      speed: 3,
      jumpPower: 10,
      onGround: false,
      isSuper: false,
      superTime: 0,
      lives: 3,
      score: 0
    };

    const gravity = 0.5;
    const keys = {};
    let platforms, enemies, powerUps, exitPortal;

    document.addEventListener('keydown', e => keys[e.code] = true);
    document.addEventListener('keyup', e => keys[e.code] = false);

    function loadLevel(index) {
      const lvl = levels[index];
      platforms = lvl.platforms.map(p => ({...p}));
      enemies = lvl.enemies.map(e => ({...e}));
      powerUps = lvl.powerUps.map(p => ({...p}));
      exitPortal = {...lvl.exitPortal};
      player.x = 100;
      player.y = 100;
      player.vx = 0;
      player.vy = 0;
      levelComplete = false;
    }

    function update() {
      if (gameOver || levelComplete) return;

      player.vx = 0;
      if (keys['ArrowLeft']) player.vx = -player.speed;
      if (keys['ArrowRight']) player.vx = player.speed;
      if (keys['Space'] && player.onGround) {
        player.vy = -player.jumpPower;
        player.onGround = false;
      }

      player.vy += gravity;
      player.x += player.vx;
      player.y += player.vy;

      player.onGround = false;
      for (let plat of platforms) {
        if (rectCollision(player, plat)) {
          if (player.vy > 0 && player.y + player.height - player.vy <= plat.y) {
            player.y = plat.y - player.height;
            player.vy = 0;
            player.onGround = true;
          }
        }
      }

      for (let enemy of enemies) {
        enemy.x += enemy.dir * 1.5;
        if (enemy.x <= 0 || enemy.x + enemy.width >= canvas.width) enemy.dir *= -1;
        if (rectCollision(player, enemy)) {
          if (!player.isSuper) {
            player.lives--;
            if (player.lives <= 0) gameOver = true;
          } else {
            player.score += 50;
          }
          player.vy = -5;
        }
      }

      for (let p of powerUps) {
        if (p.active && rectCollision(player, p)) {
          p.active = false;
          player.isSuper = true;
          player.superTime = 300;
          player.score += 100;
        }
      }

      if (player.isSuper) {
        player.superTime--;
        if (player.superTime <= 0) player.isSuper = false;
      }

      if (rectCollision(player, exitPortal)) {
        levelComplete = true;
        fadeToNextLevel();
      }

      draw();
      updateHUD();
      requestAnimationFrame(update);
    }

    function fadeToNextLevel() {
      fade.style.opacity = 1;
      setTimeout(() => {
        currentLevel++;
        if (currentLevel < levels.length) {
          loadLevel(currentLevel);
          fade.style.opacity = 0;
          requestAnimationFrame(update);
        } else {
          hud.textContent = "üéâ Hai completato tutti i livelli! ‚≠ê Punti: " + player.score;
        }
      }, 1500);
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const radius = player.isSuper ? 180 : 100;
      const gradient = ctx.createRadialGradient(
        player.x + player.width/2, player.y + player.height/2, 10,
        player.x + player.width/2, player.y + player.height/2, radius
      );
      gradient.addColorStop(0, "rgba(255, 255, 150, 0.9)");
      gradient.addColorStop(1, "rgba(0, 0, 0, 1)");

      ctx.globalCompositeOperation = 'destination-out';
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.globalCompositeOperation = 'source-over';

      ctx.fillStyle = "#444";
      platforms.forEach(p => ctx.fillRect(p.x, p.y, p.width, p.height));
      enemies.forEach(e => ctx.drawImage(spriteEnemy, e.x, e.y, e.width, e.height));
      powerUps.forEach(p => {
        if (p.active) ctx.drawImage(spritePower, p.x, p.y, p.width, p.height);
      });
      ctx.drawImage(spritePortal, exitPortal.x, exitPortal.y, exitPortal.width, exitPortal.height);
      ctx.drawImage(spriteLumi, player.x, player.y, player.width, player.height);
    }

    function updateHUD() {
      time += 1 / 60;
      let hearts = "‚ù§Ô∏è".repeat(player.lives);
      let timeStr = Math.floor(time);
      hud.textContent = `${hearts} ‚Äî üïì Tempo: ${timeStr}s ‚Äî ‚≠ê Punti: ${player.score}`;
      if (gameOver) hud.textContent = "üíÄ GAME OVER ‚Äî Premi F5 per riprovare";
    }

    function rectCollision(a, b) {
      return a.x < b.x + b.width &&
             a.x + a.width > b.x &&
             a.y < b.y + b.height &&
             a.y + a.height > b.y;
    }
  </script>
</body>
</html>
